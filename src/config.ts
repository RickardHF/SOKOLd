/**
 * Configuration management for SOKOLd
 * 
 * Settings are stored in .specify/config.yaml and can be:
 * - Set via CLI: sokold config set <key> <value>
 * - Read via CLI: sokold config get <key>
 * - Listed via CLI: sokold config list
 */
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { parse, stringify } from 'yaml';

export interface SokoldConfig {
  /** AI CLI tool to use: 'copilot' or 'claude' */
  tool: 'copilot' | 'claude';
  
  /** Model to use (tool-specific) */
  model?: string;
  
  /** Auto-approve all tool calls without prompting */
  autoApprove: boolean;
  
  /** Show verbose output */
  verbose: boolean;
  
  /** Output format */
  output: {
    colors: boolean;
    format: 'human' | 'json';
  };
  
  /** Workflow settings */
  workflow: {
    /** Force all features to use current branch (no new branches/folders) */
    currentBranchOnly: boolean;
  };
  
  /** Custom prompt templates directory */
  promptsDir?: string;
}

const DEFAULT_CONFIG: SokoldConfig = {
  tool: 'copilot',
  model: undefined,
  autoApprove: true,
  verbose: false,
  output: {
    colors: true,
    format: 'human',
  },
  workflow: {
    currentBranchOnly: false,
  },
};

const CONFIG_DIR = '.sokold';
const CONFIG_FILE = 'config.yaml';

/**
 * Get the path to the config file
 */
export function getConfigPath(rootPath: string = process.cwd()): string {
  return join(rootPath, CONFIG_DIR, CONFIG_FILE);
}

/**
 * Ensure the config directory exists
 */
function ensureConfigDir(rootPath: string = process.cwd()): void {
  const configDir = join(rootPath, CONFIG_DIR);
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
}

/**
 * Load configuration from disk, merging with defaults
 */
export function loadConfig(rootPath: string = process.cwd()): SokoldConfig {
  const configPath = getConfigPath(rootPath);
  
  if (!existsSync(configPath)) {
    return { ...DEFAULT_CONFIG };
  }
  
  try {
    const content = readFileSync(configPath, 'utf-8');
    const loaded = parse(content) as Partial<SokoldConfig>;
    
    // Deep merge with defaults
    return {
      ...DEFAULT_CONFIG,
      ...loaded,
      output: {
        ...DEFAULT_CONFIG.output,
        ...loaded.output,
      },
      workflow: {
        ...DEFAULT_CONFIG.workflow,
        ...loaded.workflow,
      },
    };
  } catch {
    console.warn(`Warning: Could not parse ${configPath}, using defaults`);
    return { ...DEFAULT_CONFIG };
  }
}

/**
 * Save configuration to disk
 */
export function saveConfig(config: SokoldConfig, rootPath: string = process.cwd()): void {
  ensureConfigDir(rootPath);
  const configPath = getConfigPath(rootPath);
  
  const content = stringify(config, {
    indent: 2,
    lineWidth: 120,
  });
  
  // Add header comment
  const header = `# SOKOLd Configuration
# Generated by: sokold init
# 
# Settings can be changed via CLI:
#   sokold config set tool claude
#   sokold config set model gpt-4
#   sokold config list
#
`;
  
  writeFileSync(configPath, header + content, 'utf-8');
}

/**
 * Initialize the config file with defaults if it doesn't exist
 * Returns true if a new config was created, false if it already existed
 */
export function initConfig(rootPath: string = process.cwd()): boolean {
  const configPath = getConfigPath(rootPath);
  
  if (existsSync(configPath)) {
    return false; // Already exists
  }
  
  // Create with defaults
  saveConfig({ ...DEFAULT_CONFIG }, rootPath);
  return true;
}

/**
 * Check if SOKOLd config exists
 */
export function hasConfig(rootPath: string = process.cwd()): boolean {
  return existsSync(getConfigPath(rootPath));
}

/**
 * Get a specific config value by dot-notation key
 */
export function getConfigValue(key: string, rootPath: string = process.cwd()): unknown {
  const config = loadConfig(rootPath);
  const parts = key.split('.');
  
  let value: unknown = config;
  for (const part of parts) {
    if (value && typeof value === 'object' && part in value) {
      value = (value as Record<string, unknown>)[part];
    } else {
      return undefined;
    }
  }
  
  return value;
}

/**
 * Set a specific config value by dot-notation key
 */
export function setConfigValue(key: string, value: string, rootPath: string = process.cwd()): void {
  const config = loadConfig(rootPath);
  const parts = key.split('.');
  
  // Navigate to the parent object
  let target: Record<string, unknown> = config as unknown as Record<string, unknown>;
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    if (!(part in target) || typeof target[part] !== 'object') {
      target[part] = {};
    }
    target = target[part] as Record<string, unknown>;
  }
  
  // Set the value, converting types as needed
  const finalKey = parts[parts.length - 1];
  target[finalKey] = parseValue(value);
  
  saveConfig(config, rootPath);
}

/**
 * Parse a string value into appropriate type
 */
function parseValue(value: string): unknown {
  // Boolean
  if (value === 'true') return true;
  if (value === 'false') return false;
  
  // Number
  const num = Number(value);
  if (!isNaN(num) && value.trim() !== '') return num;
  
  // String
  return value;
}

/**
 * List all config values in a flat format
 */
export function listConfig(rootPath: string = process.cwd()): Record<string, unknown> {
  const config = loadConfig(rootPath);
  return flattenConfig(config);
}

/**
 * Flatten nested config into dot-notation keys
 */
function flattenConfig(obj: unknown, prefix = ''): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  
  if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
    for (const [key, value] of Object.entries(obj)) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        Object.assign(result, flattenConfig(value, fullKey));
      } else {
        result[fullKey] = value;
      }
    }
  }
  
  return result;
}

/**
 * Get all available config keys with descriptions
 */
export function getConfigKeys(): Record<string, string> {
  return {
    'tool': 'AI CLI tool to use: copilot or claude',
    'model': 'Model to use (e.g., gpt-4, claude-3-opus)',
    'autoApprove': 'Auto-approve all tool calls without prompting',
    'verbose': 'Show verbose output during execution',
    'output.colors': 'Enable colored output',
    'output.format': 'Output format: human or json',
    'workflow.currentBranchOnly': 'Force all features to use current branch (no new branches/folders)',
    'promptsDir': 'Custom prompt templates directory',
  };
}

/**
 * Validate a config key-value pair
 */
export function validateConfigValue(key: string, value: string): string | null {
  switch (key) {
    case 'tool':
      if (!['copilot', 'claude'].includes(value)) {
        return `Invalid tool "${value}". Must be "copilot" or "claude"`;
      }
      break;
    case 'output.format':
      if (!['human', 'json'].includes(value)) {
        return `Invalid format "${value}". Must be "human" or "json"`;
      }
      break;
    case 'autoApprove':
    case 'verbose':
    case 'output.colors':
    case 'workflow.currentBranchOnly':
      if (!['true', 'false'].includes(value)) {
        return `Invalid value "${value}". Must be "true" or "false"`;
      }
      break;
  }
  return null;
}
